
! function (t, e) {"objeto" == tipo de exportação && "objeto" == tipo de módulo? module.exports = e (): "function" == typeof define && define.amd? define ("Noty", [], e): "objeto" == tipo de exportações? exports.Noty = e (): t.Noty = e ()} (this, function () {função return (t) {função e (o) {if (n [ o]) return n [o] .export; var i = n [o] = {i: o, l:! 1, exportações: {}}; retorno t [o] .call (i.export, i, i .exporta, e), il =! 0, i.exporta} var n = {}; retorna em = t, ec = n, ei = função (t) {retorno t}, ed = função (t, n, o ) {eo (t, n) || Object.defineProperty (t, n, {configurável:! 1, enumerável:! 0, get: o})}, en = função (t) {var n = t && t .__ esMódulo? function () {retornar t.default}: function () {retornar t}; retorno ed (n, "a", n), n}, e o = function (t, e) {return Objeto.prototipo.hasOwnProperty.call (t, e)}, ep = "", e (es = 6)} ([função (t, e, n) {"usar estrito"; função o (t,e, n) {var o = void 0; se (! n) {para (o em e) se (e.hasOwnProperty (o) && e [o] === t) retorna! 0} mais para (o in e ) if (e.hasOwnProperty (o) && e [o] === t) return! 0; return! 1} função i (t) {t = t || window.event, void 0! == t.stopPropagation? t.stopPropagation (): t.cancelBubble =! 0} função r () {var t = argumentos.length> 0 && void 0! == argumentos [0]? argumentos [0]: "", e = "noty _" + t + "_"; retorne e + = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx" .replace (/ [xy] / g, função (t) {var e = 16 * Math.random () | 0; return ("x "=== t? e: 3 & e | 8) .toString (16)})} função s (t) {var e = t.offsetHeight, n = window.getComputedStyle (t); retorno e + = parseInt (n.marginTop ) + parseInt (n.marginBottom)} função u (t, e, n) {var = argumentos.length> 3 && void 0! == argumentos [3] && argumentos [3]; e = e.split (""); para (var i = 0; i <e.length; i ++) document.addEventListener? t.addEventListener (e [i], n, o): document.attachEvent &&t.attachEvent ("on" + ee [i], n)} function a (t, e) {return ("string" == tipo de t? t: f (t)). indexOf ("+ + +" ")> = 0} funç˜ao c (t, e) {var n = f (t), o = n + e; a (n, e) || ( t.className = o.substring (1))} função l (t, e) {var n = f (t), o = void 0; a (t, e) && (o = n.replace ("" + e + "", ""), t.className = o.substring (1, o.length-1))} função d (t) {t.parentNode && t.parentNode.removeChild (t)} função f (t) {return ("" + (t && t.className || "") + "") .replace (/ \ s + / gi, "")} função h () {função t () {b.PageHidden = documento [s], o ()} função e () {b.PageHidden =! 0, o ()} função n () {b.PageHidden =! 1, o ()} função o () {b.PageHidden? i (): r ( )} função i () {setTimeout (function () {Object.keys (b.Store) .forCada (função (t) {b.Store.hasOwnProperty (t) && b.Store [t] .options.visibilityControl && b.Store [t] .stop ()})}, 100)} função r () {setTimeout (function () {Object.keys (b.Store). forEach (function (t) {b.Store.hasOwnProperty (t) && b.Store [t] .options.visibilityControl && b.Store [t] .resume ()}), b.queueRenderAll ()}, 100)} var s = void 0, a = void 0; void 0! == document.hidden? (s = "oculto", a = "visibilitychange"): void 0! == document.msHidden? (s = "msHidden", a = " msvisibilitychange "): void 0! == document.webkitHidden && (s =" webkitHidden ", a =" webkitvisibilitychange "), um && u (documento, a, t), u (janela," desfoque ", e), u (janela, "focus", n)} função p (t) {if (t.hasound) {var e = document.createElement ("audio"); t.options.sounds.sources.forEach (função (t) {var n = document.createElement ("source"); n.src = t,n.type = "audio /" + m (t), e.appendChild (n)}), t.barDom? t.barDom.appendChild (e): document.querySelector ("corpo"). appendChild (e), e.volume = t.options.sounds.volume, t.soundPlayed || (e.play (), t.soundPlayed =! 0), e.onended = função () {d (e)}}} função m ( t) {return t.match (/ \. ([^.] +) $ /) [1]} Object.defineProperty (e, "__ esModule", {valor:! 0}), e.css = e.deepExtend = e.animationEndEvents = void 0; var v = "função" == typeof Symbol && "symbol" == tipoof Symbol.iterator? function (t) {retorno typeof t}: função (t) {return t && "function" == typeof Symbol && t.constructor === Símbolo && t! == Symbol.prototype? "símbolo": typeof t}; e.inArray = o, e.stopPropagation = i, e.generateID = r, e.outerHeight = s, e.addListener = u, e.hasClass = a, e.addClass = c, e.removeClass = l, e.remove = d, e.classList = f, e.visibilityChangeFlow = h, e.createAudioElements = p; var y = n (1), b = função (t) {if (t && t .__ esModule) return t; var e = {}; if (null! = t) para (var n em t) Object. prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e.default = t, e} (y); e.animationEndEvents = "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend final de animao", e. deepExtend = função t (e) {e = e || {}; para (var n = 1; n <argumentos.length; n ++) {var o = argumentos [n]; se (o) para (var i in o ) o.hasOwnProperty (i) && (Array.isArray (o [i])? e [i] = o [i]: "objeto" === v (o [i]) && null! == o [i] e [i] = t (e [i], o [i]): e [i] = o [i]}} e}, e.css = function () {função t (t) {retorno t .replace (/ ^ - ms - /, "ms -"). substitua (/ - ([\ da-z]) / gi, função (t, e) {retorne e.toUpperCase ()})} função e ( t) {var e = document.body.style; if (t in e) retorna t; para (var n = i.length, o = t.charAt (0) .toUpperCase () + t.slice (1), r = void 0; n--;) if ((r = i [n] + o) em e) retorno r; retorno t} função n (n) {retorno n = t (n), r [n] || (r [n] = e ( n))} função o (t, e, o) {e = n (e), t.style [e] = o} var i = ["Webkit", "O", "Moz", "ms"] , r = {}; função de retorno (t, e) {var n = argumentos, i = void 0, r = void 0; if (2 === n.length) para (i em e) e.hasOwnProperty (i e & e.hasOwnProperty (i) && o (t, i, r); função (t, e, n) {"usar estrito"; função o () {var t = argumentos.length> 0 && void 0! == argumentos [0]? argumentos [0]: "global", e = 0, n = x; retorno E.hasOwnProperty (t) && (n = E [t] .maxVisible, Object.keys (P). forEach (função (n) {P [n] .options.queue! == t || P [n] .closed || e ++})), {atual: e, maxVisible: n}} função i (t) {E.hasOwnProperty (t.options.queue) || (E [t.options.queue] = {maxVisible: x, fila: []}), E [t.options.queue] .queue.push (t)} função r (t) {if (E.hasOwnProperty (t.options.queue)) {var e = []; Objeto.chaves (E [t.options.queue] .queue) .forCada (função (n) {E [t.options.queue] .queue [ n] .id! == t.id && e.push (E [t.options.queue] .queue [n])}), E [t.options.queue] .queue = e}} função s () {var t = arguments.length> 0 && void 0! == argumentos [0]? argumentos [0]: "global"; if (E.hasOwnProperty (t)) {var e = E [t] .queue.shift (); e & e .show ()}} função u () {Object.keys (E). forEach (função (t) {s (t)})} função a (t) {var e = k.generateID ("fantasma"), n = document.createElement ("div"); n.setAttribute ("id", e), k.css (n, {altura: k.outerHeight (t.barDom) + "px"}), t.barDom. insertAdjacentHTML ("afterend", n.outerHTML), k.remove (t.barDom), n = document.getElementById (e), k.addClass (n, "nony_fix_effects_height"), k.addListener (n, k.animationEndEvents, function () {k.remove (n)})} função c (t) {m (t); var e = '<div classe = "noty_body">' + t.options.text + "</ div>" + d (t) + ' <div class = "noty_progressbar"> </ div> '; t.barDom = document.createElement ("div"), t.barDom.setAttribute ("id", t.id), k.addClass (t.barDom, "noty_bar noty_type __" + t.options.type + "noty_theme__" + t.options.theme), t.barDom.innerHTML = e, b (t, "onTemplate")} função l (t) {return! (! t. options.buttons ||! Object.keys (t.options.buttons) .length)} função d (t) {se (l (t)) {var e = document.createElement ("div"); return k.addClass (e, "noty_buttons"), teclas Object.keys (t.options.buttons) .forEach (função (n) {e.appendChild (t.options.buttons [n] .dom)}), t.options.buttons. forEach (function (t) {e.appendChild (t.dom)}), e.outerHTML} retornar ""} função f (t) {t.options.Modalidade && (0 === C && p (), e.DocModalCount = C + = 1)} função h (t) {se (t.options.modal && C> 0 && (e.DocModalCount = C- = 1, C <= 0)) {var n = document.querySelector (".noty_modal"); n && (k.removeClass (n, "noty_modal_open"), k.addClass (n, "número_do_modelo_close"), k.addListener (n, k.animationEndEvents, função ( ) {k.remove (n)}))}} função p () {var t = document.querySelector ("corpo"), e = document.createElement ("div"); k.addClass (e, "noty_modal" ), t.insertBefore (e, t.firstChild), k.addClass (e, "noty_modal_open"), k.addListener (e, k.animationEndEvents, função () {k.removeClass (e, "noty_modal_open")}) } função m (t) {if (t.options.container) retornar void (t.layoutDom = document.querySelector (t.options.container)); var e = "tamanho_de_origem__" + t.options.layout; t.layoutDom = documento.querySelector ("div #" + e), t.layoutDom || (t.layoutDom = document.createElement ("div"), t.layoutDom.setAttribute ("id", e), t.layoutDom.setAttribute ("função "," alert "), t.layoutDom.setAttribute (" aria-live "," educado "), k.addClass (t.layoutDom," noty_layout "), document.querySelector (" corpo "). appendChild (t. layoutDom))} função v (t) {t.options.timeout && (t.options.progressBar && t.progressDom && k.css (t.progressDom, {transição: "largura" + t.options.timeout + "ms linear", largura: " 0% "}), clearTimeout (t.closeTimer), t.closeTimer = setTimeout (função () {t.close ()}, t.options.timeout))} função y (t) {t.options.timeout && t. closeTimer && (clearTimeout (t.closeTimer), t.closeTimer = -1, t.options.progressBar && t.progressDom && k.css (t.progressDom, {transição: "largura 0ms linear", largura: "100%"}))} função b (t, e) {t.listener.hasOwnProperty (e) && t.listeners [e] .forEach (função (e) {"function" == typeof e && e.apply (t)})} função w (t) {b (t, "afterShow"), v (t), k.addListener (t.barDom, "mouseenter", função ( ) {y (t)}), k.addListener (t.barDom, "mouseleave", função () {v (t)})} função g (t) {excluir P ​​[t.id], t.closing = ! 1, b (t, "afterClose"), k.remove (t.barDom), 0! == t.layoutDom.querySelectorAll (". Noty_bar"). Length || t.options.container || k.remove (t.layoutDom), (k.inArray ("docVisible", t.options.titleCount.conditions) || k.inArray ("docHidden", t.options.titleCount.conditions)) && D.decrement (), s ( t.options.queue)} Object.defineProperty (e, "__ esModule", {valor:! 0}), e.Defaults = e.Armazenar = e.Queues = e.DefaultMaxVisible = e.docTitle = e.DocModalCount = e.PageHidden = void 0, e.getQueueCounts = o, e.addToQueue = i, e.removeFromQueue = r, e.queueRender = s, e.queueRenderAll = u, e.ghostFix = a, e.build = c, e.hasButtons = l, e.handleModal = f, e.handleModalClose = h, e.queueClose = v, e.dequeueFechar = y, e.fire = b, e.openFlow = w , e.closeFlow = g; var _ = n (0), k = função (t) {if (t && t .__ esModule) return t; var e = {}; if (null! = t) para (var n em t Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e.default = t, e} (_), C = (e.PageHidden =! 1, e .DocModalCount = 0), S = {originalTitle: nulo, contagem: 0, alterado:! 1, temporizador: -1}, D = e.docTitle = {incremento: função () {S.count ++, D._update () }, decrement: function () {if (- S.count <= 0) return void D._clear (); D._update ()}, _ update: function () {var t = document.title; S.changed ? document.title = "(" + S.count + ")" + S.originalTitle: (S.originalTitle = t, document.title = "(" + S.count + ")" + t, S.changed =! 0)}, _ claro: function () {S.changed && (S.count = 0, document.title = S.originalTitle, S. changed =! 1)}}, x = e.DefaultMaxVisible = 5, E = e.Queues = {global: {maxVisible: x, fila: []}}, P = e.Store = {}; e.Defaults = {type: "alerta", layout: "topRight", tema: "mint", texto: "", tempo limite:! 1, progressBar:! 0, closeCom: ["click"], animação: {open: "noty_effects_open" , close: "noty_effects_close"}, id:! 1, force:! 1, killer:! 1, fila: "global", container:! 1, botões: [], retornos de chamada: {beforeShow: null, onShow: null, afterShow: null, onClose: null, afterClose: nulo, onClick: null, onHover: nulo, onTemplate: null}, sons: {fontes: [], volume: 1, condições: []}, titleCount: {condições: [] }, modal:! 1, visibilityControl:! 1}}, função (t, e, n) {"usar estrito"; função o (t, e) {if (!(t instanceof e)) lançar novo TypeError ("Não é possível chamar uma classe como uma função")} Object.defineProperty (e, "__ esModule", {valor:! 0}), e.NotyButton = void 0; var i = n (0), r = função (t) {if (t & t & ____Esmodule) return t; var e = {}; if (null! = T) para (var n em t) Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e.default = t, e} (i); e.NotyButton = função t (e, n, i) {var s = isto, u = argumentos .length> 3 && void 0! == argumentos [3]? argumentos [3]: {}; retorne o (this, t), this.dom = document.createElement ("botão"), this.dom.innerHTML = e, this.id = u.id = u.id || r.generateID ("botão"), this.cb = i, Object.keys (u) .forEach (função (t) {s.dom.setAttribute (t, u [t])}), r.addClass (this.dom, n || "noty_btn"), isto}}, função (t, e, n) {"usar estrito"; função o (t, e) { if (! (t instanceof e)) lança novo TypeError ("Não é possível chamar uma classe como uma função ")} Object.defineProperty (e," __ esModule ", {valor:! 0}); var i = função () {função t (t, e) {para (var n = 0; n <e.length; n ++) {var o = e [n]; o.enumerável = o.enumerável ||! 1, o.configurável =! 0, "valor" em o && (o.writable =! 0), Object.defineProperty (t, o.key, o)}} função de retorno (e, n, o) {retornar n && t (e.prototype, n), o && t (e, o), e}} (); = function () {função t () {var e = argumentos.length> 0 && void 0! == argumentos [0]? argumentos [0]: "/ service-worker.js"; retorno o (isto, t), este .subData = {}, this.workerPath = e, this.listeners = {onPermissionGranted: [], onPermissionDenied: [], onSubscriptionSuccess: [], onSubscriptionCancel: [], onWorkerError: [], onWorkerSuccess: [], onWorkerNotSupported: [ }}, this} return i (t, [{chave: "on", valor: função (t) {var e = argumentos.length> 1 && void 0!== argumentos [1]? argumentos [1]: function () {}; retorno "function" == typeof e && this.listeners.hasOwnProperty (t) && this.listeners [t] .push (e), este}}, { key: "fire", valor: function (t) {var e = isto, n = argumentos.length> 1 && void 0! == argumentos [1]? argumentos [1]: []; this.listeners.hasOwnProperty (t) && this.listeners [t] .forEach (função (t) {"função" == typeof t && t.apply (e, n)})}}, {chave: "criar", valor: function () {console.log ( "NÃO IMPLEMENTADO AINDA")}}, {chave: "isSupported", valor: function () {var t =! 1; tente {t = janela.Notificação || window.webkitNotifications || navigator.mozNotification || window.external && void 0! == window.external.msIsSiteMode ()} catch (t) {} retorna t}}, {chave: "getPermissionStatus", valor: function () {var t = "default"; if (janela.Notificação && janela.Notification.permissionLevel) t = window.Notification.permissionLevel; else if (window.webkitNotifications&& window.webkitNotifications.checkPermission) switch (window.webkitNotifications.checkPermission ()) {caso 1: t = "padrão"; quebra; caso 0: t = "concedido"; quebrar; padrão: t = "negado"} mais window.Notification && window.Notification.permission? t = window.Notification.permission: navigator.mozNotification? t = "concedido": window.external && void 0! == janela. external.msIsSiteMode () && (t = window.external.msIsSiteMode ()? "concedido": "default"); return t.toString (). toLowerCase ()}}, {chave: "getEndpoint", valor: function ( t) {var e = t.endpoint, n = t.subscriptionId; return n && - 1 === e.indexOf (n) && (e + = "/" + n), e}}, {chave: "isSWRegistered" , value: function () {try {retorno "ativado "=== navigator.serviceWorker.controller.state} catch (t) {retorno! 1}}}, {chave:" unregisterWorker ", valor: function () {var t = isso;" serviceWorker "no navegador && navigator.serviceWorker .getRegistrations (). then (function (e) {var n =! 0, o =! 1, i = void 0; try {para (var r, s = e [Symbol.iterator] ();! (n = (r = s.next ()). done); n =! 0) {r.value.unregister (), t.fire ("onSubscriptionCancel")}} captura (t) {o =! 0, i = t } finalmente {try {! n && s.return && s.return ()} finalmente {if (o) throw i}}})}}, {key: "requestSubscription", valor: function () {var t = isto, e =! (arguments.length> 0 && void 0! == argumentos [0]) || argumentos [0], n = isto, o = this.getPermissionStatus (), i = função (o) {"concedido" === o? ( t.fire ("onPermissionGranted"), "serviceWorker" no navegador? navigator.serviceWorker.register (t.workerPath).então (function () {navigator.serviceWorker.ready.then (função (t) {n.fire ("onWorkerSuccess"), t.pushManager.subscribe ({userVisibleOnly: e}). então (function (t) {var e = t.getKey ("p256dh"), o = t.getKey ("auth"); n.subData = {ponto final: n.getEndpoint (t), p256dh: e? window.btoa (String.fromCharCode.apply (null) , new Uint8Array (e))): nulo, auth: o? window.btoa (String.fromCharCode.apply (nulo, novo Uint8Array (o))): nulo}, n.fire ("onSubscriptionSuccess", [n.subData ])}). catch (função (t) {n.fire ("onWorkerError", [t])})})}): n.fire ("onWorkerNotSupported")): "negado" === o && (t .fire ("onPermissionDenied"), t.unregisterWorker ())}; "default" === o? window.Notification && window.Notification.requestPermission? window.Notification.requestPermission (i): janela.webkitNotifications && janela.webkitNotifications.checkPermission && window.webkitNotifications.requestPermission (i): i (o)}}]), t} ()}, função (t, e, n) {(função (e, o) {

! função (e, n) {t.exporta = n ()} (0, função () {"usar estrito"; função t (t) {var e = tipo de t; retorno nulo! == t && ("objeto" === e || "function" === e)} função i (t) {retorno "function" == typeof t} função r (t) {z = t} função s (t) {U = t} function u () {return void 0! == R? função () {R (c)}: a ()} função a () {var t = setTimeout; função return () {return t (c, 1)} } função c () {para (var t = 0; t <Q; t + = 2) {(0, X [t]) (X [t + 1]), X [t] = vazio 0, X [t +1] = void 0} Q = 0} função l (t, e) {var n = argumentos, o = isto, i = novo this.constructor (f); void 0 === i [tt] && A (i ); var r = o._state; retorno r? função () {var t = n [r-1]; U (função () {retorno P (r, i, t, o._resultado)})} () : S (o, i, t, e), i} função d (t) {var e = isso; if (t && "objeto" == tipo de t && t.construtor === e) retorno t; var n = novo e (f); retorno g (n, t), n} função f () {} função h () {return new TypeError ("Você não pode resolver uma promessa com ela mesma ")} function p () {return new TypeError (" Um callback prometido não pode retornar a mesma promessa. ")} Function m (t) {try {return t.then} catch (t) { return it.error = t, it}} v (t, e, n, o) {try {t.call (e, n, o)} captura (t) {retorno t}} função y (t, e , n) {U (função (t) {var o =! 1, i = v (n, e, função (n) {o || (o =! 0, e! = n n? g (t, n ): k (t, n))}, função (e) {o || (o =! 0, C (t, e))}, "Liquidar:" + (t._label || "promessa desconhecida") ); & o && i && (o =! 0, C (t, i))}, t)} função b (t, e) {e._state === nt? k (t, e._result): e._state === ot? C (t, e._result): S (e, vazio 0, função (e) {retorno g (t, e)}, função (e) {retorno C (t, e)})} função w (t, e, n) {e.construtor === t.construtor && n === l && e.constructor.resolve === d? b (t, e): n === it? (C (t, it.error), it.error = null): void 0 === n? k (t, e): i (n)? y (t, e, n): k (t, e)} função g ( e, n) {e === n? C (e, h ()): t (n)? w (e, n,m (n): k (e, n)} função _ (t) {t._onerror && t._onerror (t._result), D (t)} função k (t, e) {t._state === et && (t._result = e, t._state = nt, 0! == t._subscribers.length && U (D, t))} função C (t, e) {t._state === et && (t._state = ot , t._result = e, U (_, t))} função S (t, e, n, o) {var i = t.subscribers, r = i.length; t._onerror = null, i [r] = e, i [r + nt] = n, i [r + ot] = o, 0 == r && t._state && U (D, t)} função D (t) {var e = t.subscribers, n = t ._state; if (0! == e.length) {para (var o = void 0, i = void 0, r = t.resultado, s = 0; s <e.length; s + = 3) o = e [s], i = e [s + n], o? P (n, o, i, r): i (r); t._subscribers.length = 0}} função x () {this.error = null } função E (t, e) {tentar {retornar t (e)} pegar (t) {retornar rt.error = t, rt}} função P (t, e, n, o) {var r = i (n ), s = void 0, u = void 0, a = void 0, c = void 0, se (r) {se (s = E (n, o), s = = rt (c = 0, u = s.error, s.error = null): a =! 0, e === s) retornar void C (e, p ())} mais s = o, a =! 0; e._state! = et || (r &&a? g (e, s): c? C (e, u): t === nt? k (e, s): t === ot && C (e, s)}} função {try {e (função (e) {g (t, e)}, função (e) {C (t, e)}}} captura (e) {C (t, e)}} função O () { return st ++} function A (t) {t [tt] = st ++, t._state = void 0, t.result = void 0, t._subscribers = []} função M (t, e) {this._instanceConstructor = t , this.promise = new t (f), this.promise [tt] || A (this.promise), I (e)? (this.length = e.length, this._maining = e.length, this. _result = new Matriz (this.length), 0 === this.length k (this.promise, this._result) :( this.length = this.length || 0, this._enumerate (e), 0 = == this._remaining && k (this.promise, this._result))): C (this.promise, q ())} função q () {return new Error ("Métodos de Array devem ser fornecidos uma Matriz")} function j (t) {return new M (isto, t) .promise} function N (t) {var e = isto; return new e (eu (t)? função (n, o) {para (var i = t.length , r = 0; r <i; r ++) e.resolve (t [r]). então (n, o)}: function (t,e) {return e (new TypeError ("Você deve passar um array para race."))})} function L (t) {var e = this, n = new e (f); retorno C (n, t) , n} função H () {lançar novo TypeError ("Você deve passar uma função de resolver como o primeiro argumento para o construtor promessa")} função W () {lançar novo TypeError ("Falha ao construir 'Promise': Por favor, use o 'new' operator, este construtor de objeto não pode ser chamado como uma função. ")} function V (t) {isto [tt] = O (), this._result = this._state = void 0, this._subscribers = [] , f! == t && ("função"! = typeof t && H (), esta instância de V? T (isto, t): W ()}} função B () {var t = void 0; if (void 0! = = o) t = o; else if ("indefinido"! = tipo de self) t = self; else try {t = Função ("retornar isto") ()} catch (t) {lançar novo Erro ("polyfill falhou porque objeto global está indisponível neste ambiente ")} var e = t.Promise; if (e) {var n = null; tente {n = Object.prototype.toString.call (e.resolve ())} catch (t) {} if ("[objeto Promise ] "=== n &&! e.cast) return} t.Promise = V} var F = void 0; F = Array.isArray? Array.isArray: function (t) {return" [array objeto] "=== Object.prototype.toString.call (t)}; var I = F, Q = 0, R = vazio 0, z = vazio 0, U = função (t, e) {X [Q] = t, X [Q +1] = e, 2 === (Q + = 2) && (z? Z (c): Z ())}, Y = "indefinido"! = Janela typeof window ?: void 0, K = Y || {}, G = K.MutationObserver || K.WebKitMutationObserver, $ = "indefinido" == typeof self && void 0! == e && "[processo de objeto]" === {}. ToString.call (e), J = " indefinido "! = tipo de Uint8ClampedArray &&" indefinido "! = typeof importScripts &&" undefined "! = typeof MessageChannel, X = novo Array (1e3), Z = void 0; Z = $? function () {função return () {return e. nextTick (c)}} ():G? Função () {var t = 0, e = novo G (c), n = document.createTextNode (""); retorno e.observe (n, {characterData:! 0}), function () {n. data = t = ++ t% 2}} (): J? function () {var t = new MessageChannel; retorno t.port1.onmessage = c, function () {retorno t.port2.postMessage (0)}} (): void 0 === Y? function () {tenta {var t = n (9); retorna R = t.runOnLoop || t.runOnContext, u ()} captura (t) {retorno a ()} } (): a (); var tt = Math.random (). toString (36) .substring (16), et = void 0, nt = 1, ot = 2, it = novo x, rt = novo x, st = 0; retorno M.prototype._enumerate = function (t) {para (var e = 0; this._state === et && e <t.length; e ++) this._eachEntry (t [e], e)}, M.prototype._eachEntry = function (t, e) {var n = este._instanceConstructor, o = n.resolve; se (o === d) {var i = m (t); se (i === l && t ._state! == et) this._settledAt (t._state, e, t._result); else if ("função"! = typeof i) this._remaining -, this._result [e] = t; (n === V) {var r = novo n (f); w (r, t, i),this._willSettleAt (r, e)} else this._willSettleAt (novo n (função (e) {retorno e (t)}), e)} else this._willSettleAt (o (t), e)}, M.prototype ._settledAt = function (t, e, n) {var o = this.promise; o._state === et && (this._remaining -, t === ot? C (o, n): this._result [ e] = n), 0 === this._maining && k (o, this._result)}, M.prototype._willSettleAt = função (t, e) {var n = isto; S (t, void 0, function (t ) {return n._settledAt (nt, e, t)}, função (t) {return n._settledAt (ot, e, t)})}, V.all = j, V.race = N, V.resolve = d, V.reject = L, V._setScheduler = r, V._setAsap = s, V._asap = U, V.prototype = {construtor: V, então: l, catch: function (t) {retorne isto. então (null, t)}}, V.polyfill = B, V.Promise = V, V})}). chamada (e, n (7), n (8))}, função (t, e) { }, function (t, e, n) {"usar estrito"; função o (t) {if (t && t .__ esModule) return t; var e = {}; if (null! = t) para (var n em t Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]);return e.default = t, e} função i (t, e) {se (! (t instanceof e)) lançar novo TypeError ("Não é possível chamar uma classe como uma função")} Object.defineProperty (e, "__ esModule" , {valor:! 0}); var r = função () {função t (t, e) {para (var n = 0; n <e.length; n ++) {var o = e [n]; enumerable = o.enumerable ||! 1, o.configurable =! 0, "valor" em o && (o.writable =! 0), Object.defineProperty (t, o.key, o)}} função de retorno (e, n, o) {return n && t (e.prototipo, n), o && t (e, o), e}} (); n (5); var s = n (4), u = função (t) {retorno t & t .__ esModule? t: {padrão: t}} (s), a = n (0), c = o (a), l = n (1), d = o (l), f = n (2), h = n (3), p = função () {função t () {var e = argumentos.length> 0 && void 0! == argumentos [0]? argumentos [0]: {}; retorno i (isto, t) , this.options = c.deepExtend ({}, d.Defaults, e), this.id = this.options.id || c.generateID ("bar"), this.closeTimer = -1, this.barDom = null, isso.layoutDom = null, this.progressDom = null, this.showing =! 1, this.shown =! 1, this.closed =! 1, this.closing =! 1, this.killable = this.options.timeout || este .options.closeWith.length> 0, this.hasSound = this.options.sounds.sources.length> 0, this.soundPlayed =! 1, this.listeners = {antesShow: [], onShow: [], afterShow: [ ], onClose: [], afterClose: [], onClick: [], onHover: [], onTemplate: []}, this.promises = {show: null, próximo: null}, this.on ("antes do show", this.options.callbacks.beforeShow), this.on ("onShow", this.options.callbacks.onShow), this.on ("afterShow", this.options.callbacks.afterShow), this.on ("onClose" , this.options.callbacks.onClose), this.on ("afterClose", this.options.callbacks.afterClose), this.on ("onClick", this.options.callbacks.onClick), this.on ("onHover ", this.options.callbacks.onHover), this.on (" onTemplate ",this.options.callbacks.onTemplate), isto} retorna r (t, [{key: "on", valor: function (t) {var e = argumentos.length> 1 && void 0! == argumentos [1]? argumentos [ 1]: function () {}; retorno "function" == typeof e && this.listeners.hasOwnProperty (t) && this.listeners [t] .push (e), isto}}, {chave: "show", valor: função () {var e = this;! 0 === this.options.killer? t.closeAll (): "string" == tipo de this.options.killer && t.closeAll (this.options.killer); var n = d .getQueueCounts (this.options.queue); if (n.current> = n.maxVisible || d.PageHidden && this.options.visibilityControl) retorna d.addToQueue (this), d.PageHidden && this.hasSound && c.inArray ("docHidden", this.options.sounds.conditions) && c.createAudioElements (this), d.PageHidden && c.inArray ("docHidden", this.options.titleCount.condições) && d.docTitle.increment (), this; if (d.Store [this.id] = isso, d.fire (isso, "beforeShow"), this.showing =! 0, this.closing) retorna isso. mostrando =! 1, this; if (d.build (this), d.handleModal (this), this.options.force? this.layoutDom.insertBefore (this.barDom, this.layoutDom.firstChild): this.layoutDom. appendChild (this.barDom), this.hasSound &&! this.soundPlayed && c.inArray ("docVisible", this.options.sounds.conditions) && c.createAudioElements (this), c.inArray ("docVisible", this.options.titleCount. condições) && d.docTitle.increment (), this.shown =! 0, this.closed =! 1, d.hasButton (this) && Object.keys (this.options.buttons) .forEach (função (t) {var n = e.barDom.querySelector ("#" + e.options.buttons [t] .id); c.addListener (n, "clique", função (n) {c.stopPropagation (n), e.options.buttons [t] .cb ()})}),this.progressDom = this.barDom.querySelector (". noty_progressbar"), c.inArray ("clique", this.options.closeWith) && (c.addClass (this.barDom, "noty_close_with_click"), c.addListener (este .barDom, "clique", função (t) {c.stopPropagation (t), d.fire (e, "onClick"), e.close ()},! 1)), c.addListener (this.barDom, "mouseenter", função () {d.fire (e, "onHover")},! 1), this.options.timeout && c.addClass (this.barDom, "noty_has_timeout"), this.options.progressBar && c.addClass (este .barDom, "noty_has_progressbar"), c.inArray ("botão", this.options.closeWith)) {c.addClass (this.barDom, "noty_close_with_button"); var o = document.createElement ("div"); c .addClass (o, "noty_close_button"), o.innerHTML = "×", this.barDom.appendChild (o), c.addListener (o,"clique", função (t) {c.stopPropagation (t), e.close ()} ,! 1)} retornar d.fire (isso, "onShow"), null === this.options.animation.open this.promises.show = new u.default (função (t) {t ()}): "função" == tipoof this.options.animation.open?this.promises.show=new u.default (this. options.animation.open.bind (this)) :( c.addClass (this.barDom, this.options.animation.open), this.promises.show = novo u.default (função (t) {c.addListener ( e.barDom, c.animationEndEvents, function () {c.removeClass (e.barDom, e.options.animation.open), t ()})})), this.promises.show.then (function () { var t = e; setTimeout (função () {d.openFlow (t)}, 100)}), isto}}, {key: "stop", valor: function () {retorno d.dequeueFechar (este), este }}, {key: "resume", valor: function () {retorno d.queueClose (this), this}}, {chave: "setTimeout", valor: function (t) {função e (e) {retorno t .apply (isso,argumentos)} return e.toString = function () {retornar t.toString ()}, e} (function (t) {if (this.stop (), this.options.timeout = t, this.barDom) {isto .options.timeout? c.addClass (this.barDom, "noty_has_timeout"): c.removeClass (this.barDom, "noty_has_timeout"); var e = isto; setTimeout (function () {e.resume ()}, 100 )} retorne isto})}, {key: "setText", valor: function (t) {var e = argumentos.length> 1 && void 0! == argumentos [1] && argumentos [1]; retorne this.barDom && (this. barDom.querySelector (".noty_body"). innerHTML = t), e && (this.options.text = t), isto}}, {chave: "setType", valor: function (t) {var e = isto, n = arguments.length> 1 && void 0! == argumentos [1] && argumentos [1]; if (this.barDom) {c.classList (this.barDom) .split ("") .forEach (função (t) {"noty_type__ "=== t.substring (0,11) && c.removeClass (por exemplo,barDom, t)}), c.addClass (this.barDom, "noty_type __" + t)} return n && (this.options.type = t), isto}}, {key: "setTheme", valor: function (t ) {var e = isto, n = argumentos.length> 1 && void 0! == argumentos [1] && argumentos [1]; if (this.barDom) {c.classList (this.barDom) .split ("") .forCada (função (t) {"noty_theme __" === t.substring (0,12) && c.removeClass (e.barDom, t)}), c.addClass (this.barDom, "noty_theme __" + t)} retorno n && (this.options.theme = t), this}}, {chave: "close", valor: function () {var t = isto; retorne this.closed? this: this.shown? (d.fire (isto, "onClose"), this.closing =! 0, null === this.options.animation.close? this.promises.close = novo u.default (função (t) {t ()}): "função" = = typeof this.options.animation.close? this.promises.close = novo u.default (this.options.animation.close.bind (this)) :( c.addClass (this.barDom, this.options.animation.close), this.promises.close = novo u.default (função (e) {c.addListener (t.barDom, c. AnimationEndEvents, function () {t.options.force? c.remove (t.barDom): d.ghostFix (t), e ()})}), this.promises.close.then (function () {d .closeFlow (t), d.handleModalClose (t)}), this.closed =! 0, isto) :( d.removeFromQueue (this), this)}}], [{chave: "closeAll", valor: função () {var t = arguments.length> 0 && void 0! == argumentos [0] && argumentos [0]; return Objeto.chaves (d.Store) .forEach (função (e) {t? d.Store [e]. options.queue === t && d.Store [e] .killable && d.Store [e] .close (): d.Store [e] .killable && d.Store [e] .close ()}), isto}}, {chave : "overrideDefaults", valor: function (t) {retorno d.Defaults = c.deepExtend ({}, d.Defaults, t), este}}, {key: "setMaxVisible", valor: function () {var = arguments.length> 0 e& void 0! == argumentos [0]? argumentos [0]: d.DefaultMaxVisible, e = argumentos.length> 1 && void 0! == argumentos [1]? argumentos [1]: "global"; retorno d.Queues.hasOwnProperty (e) || (d.Queues [e] = {maxVisible: t, fila: []}), d.Queues [e] .maxVisible = t, isto}}, {chave: "botão", valor: função (t) {var e = argumentos.length> 1 && void 0! == argumentos [1]? argumentos [1]: null, n = argumentos [2], o = argumentos.length> 3 && void 0! == argumentos [3] ? argumentos [3]: {}; retorna novo f.NotyButton (t, e, n, o)}}, {chave: "versão", valor: function () {retorno "3.1.4"}}, {chave : "Push", valor: function (t) {retornar novo h.Push (t)}}]), t} (); e.default = p, c.visibilityChangeFlow (), t.exports = e.default} , função (t, e) {função n () {lançar novo Erro ("setTimeout não foi definido")} função o () {lançar novo Erro ("clearTimeout não foi definido"}} função i (t) {if (l === setTimeout) retorna setTimeout (t, 0); if ((l === n ||! l) && setTimeout) retorna l = setTimeout, setTimeout (t, 0) ; tente {return l (t, 0)} catch (e) {tentar {retornar l.call (null, t, 0)} capturar (e) {retornar a função l.call (this, t, 0)}}} r (t) {if (d === clearTimeout) retorna clearTimeout (t); se ((d === o ||! d) && clearTimeout) retorna d = clearTimeout, clearTimeout (t); tente {retornar d (t }} catch (e) {try {return d.call (nulo, t)} catch (e) {retorno d.call (isto, t)}}} função s () {m && h && (m =! 1, h. comprimento? p = h.concat (p): v = -1, p.length && u ())} função u () {se (! m) {var t = i (s); m =! 0; para (var e = p.length; e;) {para (h = p, p = []; ++ v <e;) h & h [v] .run (); v = -1, e = p.length} h = null, m =! 1, r (t)}} function a (t, e) {this.fun = t, this.array = e} função c () {} var l, d, f = t.exports = {} ;! function () {try {l = "função" == tipoof setTimeout? setTimeout: n} captura (t) {l = n} tenta {d = "função"== tipo de clearTimeout? clearTimeout: o} pegar (t) {d = o}} (); var h, p = [], m =! 1, v = -1; f.nextTick = função (t) {var e = new Array (arguments.length-1); if (arguments.length> 1) para (var n = 1; n <argumentos.length; n ++) e [n-1] = argumentos [n]; p.push (novo a (t, e)), 1! == p.length || m || i (u)}, a.prototype.run = function () {this.fun.apply (null, this.array) }, f.title = "browser", f.browser =! 0, f.env = {}, f.argv = [], f.version = "", f.versões = {}, f.on = c , f.addListener = c, f.once = c, f.off = c, f.removeListener = c, f.removeAllListeners = c, f.emit = c, f.prependListener = c, f.prependOnceListener = c, f .listeners = function (t) {return []}, f.binding = function (t) {lançar novo erro ("process.binding não é suportado")}, f.cwd = function () {return "/"} , f.chdir = function (t) {lançar novo Erro ("process.chdir não é suportado")}, f.umask = function () {retorno 0}}, function (t, e) {var n;n = function () {retornar isto} (); tente {n = n || Função ("retornar isto") () || (0, eval) ("isto")} pegar (t) {"objeto" = = janela de tipo && (n = janela)} t.exporta = n}, função (t, e) {}])});
// # sourceMappingURL = noty.min.js.map